#pragma kernel CSInit
#pragma kernel CSUpdate

#define THREADS_PER_GROUP 64
#define MAX_LOD_COUNT 4
#include "Assets/Shaders/HLSL/BackgroundParticles.hlsl"
#include "Assets/Shaders/HLSL/Random.hlsl"

RWStructuredBuffer<BackgroundParticleOutput> _BGParticleOutputs;
StructuredBuffer<BackgroundParticleInput> _BGParticleInputs;

RWStructuredBuffer<BackgroundParticleOutput> _LODParticleOutputs0;
RWStructuredBuffer<BackgroundParticleOutput> _LODParticleOutputs1;
RWStructuredBuffer<BackgroundParticleOutput> _LODParticleOutputs2;
RWStructuredBuffer<BackgroundParticleOutput> _LODParticleOutputs3;

RWStructuredBuffer<uint> _LODWriteOffsets;

StructuredBuffer<float> _LODThresholds;

uint _BackgroundMaskCount;

float3 _SpawnerMinPos;
float3 _SpawnerMaxPos;
float3 _SpawnerSize;

uint _ParticleCount;
uniform float _TrainVelocity;

void ReinitOutput(inout BackgroundParticleOutput output, uint id)
{
    output.randID = HashIntToInt(id + output.randID);
    output.rand01 = HashIntTo01Float(output.randID);
    
    uint randMod = output.randID % _BackgroundMaskCount;
    
    BackgroundParticleInput input = _BGParticleInputs[randMod];
    
    output.position.y = input.heightPos + lerp(-input.heightRange, input.heightRange, output.rand01);
    output.backgroundMask = input.bgMask;
    output.alive = 1;
}


[numthreads(THREADS_PER_GROUP, 1, 1)]
void CSInit(uint id : SV_DispatchThreadID)
{
    if (id >= _ParticleCount)
    {
        return;
    }
    
    BackgroundParticleOutput output = _BGParticleOutputs[id];
    
    output.position.z = _SpawnerMinPos.z + (((float) id / (float) _ParticleCount) * _SpawnerSize.z);
    output.parallaxFactor = abs(output.position.z - _SpawnerMaxPos.z) / _SpawnerMaxPos.z; // TODO: Calculate between camera and furthest pos, not just the furthest pos
    
    ReinitOutput(output, id);
    output.position.x = _SpawnerMinPos.x + (_SpawnerSize.x * output.rand01);
    
    output.lod = MAX_LOD_COUNT - 1;
    for (int i = 0; i < MAX_LOD_COUNT - 1; i++)
    {
        if (output.position.z < _LODThresholds[i])
        {
            output.lod = i;
            break;
        }
    }
    
    uint lodIndex = 0;
    
    InterlockedAdd(_LODWriteOffsets[output.lod], 1, lodIndex);
    if (output.lod == 0)
    {
        _LODParticleOutputs0[lodIndex] = output;
    }
    else if (output.lod == 1)
    {
        _LODParticleOutputs1[lodIndex] = output;
    }
    else if (output.lod == 2)
    {
        _LODParticleOutputs2[lodIndex] = output;
    }
    else if (output.lod == 3)
    {
        _LODParticleOutputs3[lodIndex] = output;
    }
    
     _BGParticleOutputs[id] = output;
}

[numthreads(THREADS_PER_GROUP, 1, 1)]
void CSUpdate(uint id : SV_DispatchThreadID)
{
    if (id >= _ParticleCount)
    {
        return;
    }
    
    BackgroundParticleOutput output = _BGParticleOutputs[id];
    
    if (output.alive == 1)
    {
        output.position.x -= _TrainVelocity * output.parallaxFactor;
    
        if (output.position.x < _SpawnerMinPos.x)
        {
            output.alive = 0;
        }
    }
    else
    {
        BackgroundParticleOutput output = _BGParticleOutputs[id];
        ReinitOutput(output, id);
        output.position.x = _SpawnerMaxPos.x;
    }
    
    _BGParticleOutputs[id] = output;
}