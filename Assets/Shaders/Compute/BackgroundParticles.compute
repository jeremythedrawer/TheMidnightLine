#include "Assets/Shaders/HLSL/BackgroundParticles.hlsl"
#include "Assets/Shaders/HLSL/Random.hlsl"

#define THREADS_PER_GROUP 64

#pragma kernel CSForeground0_Init
#pragma kernel CSMiddleground0_Init
#pragma kernel CSMiddleground1_Init
#pragma kernel CSMiddleground2_Init
#pragma kernel CSMiddleground3_Init
#pragma kernel CSBackground0_Init
#pragma kernel CSBackground1_Init
#pragma kernel CSBackground2_Init

#pragma kernel CSForeground0_Update
#pragma kernel CSMiddleground0_Update
#pragma kernel CSMiddleground1_Update
#pragma kernel CSMiddleground2_Update
#pragma kernel CSMiddleground3_Update
#pragma kernel CSBackground0_Update
#pragma kernel CSBackground1_Update
#pragma kernel CSBackground2_Update

static const float FORE_MIN = 1.0;
static const float FORE_SIZE = 1.0;

static const float MID_MIN = 24.0;
static const float MID_SIZE = 4.0;

static const float BACK_MIN = 29.0;
static const float BACK_SIZE = 3.0;

static const float F0_OFFSET = 1.0;
static const float M0_OFFSET = 2.0;
static const float M1_OFFSET = 3.0;
static const float M2_OFFSET = 4.0;
static const float M3_OFFSET = 5.0;
static const float B0_OFFSET = 6.0;
static const float B1_OFFSET = 7.0;
static const float B2_OFFSET = 8.0;

RWStructuredBuffer<ParticleOutput> _Foreground0;
RWStructuredBuffer<ParticleOutput> _Middleground0;
RWStructuredBuffer<ParticleOutput> _Middleground1;
RWStructuredBuffer<ParticleOutput> _Middleground2;
RWStructuredBuffer<ParticleOutput> _Middleground3;
RWStructuredBuffer<ParticleOutput> _Background0;
RWStructuredBuffer<ParticleOutput> _Background1;
RWStructuredBuffer<ParticleOutput> _Background2;

uint _BackgroundMaskCount;

float3 _SpawnerMinPos;
float3 _SpawnerMaxPos;
float3 _SpawnerSize;

uint _ForegroundParticleCount;
uint _MiddlegroundParticleCount;
uint _BackgroundParticleCount;

uniform float _Velocity;


void InitOutput(int id, int particleCount, float minPos, float sizeRange, float offset, inout ParticleOutput output)
{
    float normID = (float) id / (float) particleCount;
    
    output.position.z = minPos + (normID * sizeRange);
    output.parallaxFactor = (_SpawnerMaxPos.z - output.position.z) / _SpawnerMaxPos.z;
    
    uint seed = id ^ asuint(offset * 123.456);
    
    output.randID = HashIntToInt(seed + output.randID);
    output.rand01 = HashIntTo01Float(output.randID);
    output.alive = 1;
    
    output.position.x = _SpawnerMinPos.x + (_SpawnerSize.x * output.rand01);
}

void UpdateOutput(inout ParticleOutput output)
{
    if (output.alive == 1)
    {
        output.position.x += _Velocity * (output.parallaxFactor);
    
        if (output.position.x < _SpawnerMinPos.x)
        {
            output.alive = 0;
        }
    }
    else
    {
        output.position.x = _SpawnerMaxPos.x;
        output.alive = 1;
    }
}

//Init
[numthreads(THREADS_PER_GROUP, 1, 1)]
void CSForeground0_Init(uint id : SV_DispatchThreadID)
{
    if (id >= _ForegroundParticleCount) return;
    
    ParticleOutput output = _Foreground0[id];
    InitOutput(id, _ForegroundParticleCount, FORE_MIN, FORE_SIZE, F0_OFFSET, output);
    
    _Foreground0[id] = output;

}

[numthreads(THREADS_PER_GROUP, 1, 1)]
void CSMiddleground0_Init(uint id : SV_DispatchThreadID)
{
    if (id >= _MiddlegroundParticleCount) return;
    
    ParticleOutput output = _Middleground0[id];
    InitOutput(id, _MiddlegroundParticleCount, MID_MIN, MID_SIZE, M0_OFFSET, output);
    
    _Middleground0[id] = output;
}

[numthreads(THREADS_PER_GROUP, 1, 1)]
void CSMiddleground1_Init(uint id : SV_DispatchThreadID)
{
    if (id >= _MiddlegroundParticleCount) return;
    
    ParticleOutput output = _Middleground1[id];
    InitOutput(id, _MiddlegroundParticleCount, MID_MIN, MID_SIZE, M1_OFFSET, output);
    _Middleground1[id] = output;
}

[numthreads(THREADS_PER_GROUP, 1, 1)]
void CSMiddleground2_Init(uint id : SV_DispatchThreadID)
{
    if (id >= _MiddlegroundParticleCount) return;
    
    ParticleOutput output = _Middleground2[id];
    InitOutput(id, _MiddlegroundParticleCount, MID_MIN, MID_SIZE, M2_OFFSET, output);
    _Middleground2[id] = output;
}

[numthreads(THREADS_PER_GROUP, 1, 1)]
void CSMiddleground3_Init(uint id : SV_DispatchThreadID)
{
    if (id >= _MiddlegroundParticleCount) return;
    
    ParticleOutput output = _Middleground3[id];
    InitOutput(id, _MiddlegroundParticleCount, MID_MIN, MID_SIZE, M3_OFFSET, output);
    _Middleground3[id] = output;
}

[numthreads(THREADS_PER_GROUP, 1, 1)]
void CSBackground0_Init(uint id : SV_DispatchThreadID)
{
    if (id >= _BackgroundParticleCount) return;
    
    ParticleOutput output = _Background0[id];
    InitOutput(id, _BackgroundParticleCount, BACK_MIN, BACK_SIZE, B0_OFFSET, output);
    _Background0[id] = output;
}

[numthreads(THREADS_PER_GROUP, 1, 1)]
void CSBackground1_Init(uint id : SV_DispatchThreadID)
{
    if (id >= _BackgroundParticleCount) return;
    
    ParticleOutput output = _Background1[id];
    InitOutput(id, _BackgroundParticleCount, BACK_MIN, BACK_SIZE, B1_OFFSET, output);
    _Background1[id] = output;
}

[numthreads(THREADS_PER_GROUP, 1, 1)]
void CSBackground2_Init(uint id : SV_DispatchThreadID)
{
    if (id >= _BackgroundParticleCount) return;
    
    ParticleOutput output = _Background2[id];
    InitOutput(id, _BackgroundParticleCount, BACK_MIN, BACK_SIZE, B2_OFFSET, output);
    _Background2[id] = output;
}





//Update
[numthreads(THREADS_PER_GROUP, 1, 1)]
void CSForeground0_Update(uint id : SV_DispatchThreadID)
{
    if (id >= _ForegroundParticleCount)
        return;
    
    ParticleOutput output = _Foreground0[id];
    UpdateOutput(output);
    _Foreground0[id] = output;

}

[numthreads(THREADS_PER_GROUP, 1, 1)]
void CSMiddleground0_Update(uint id : SV_DispatchThreadID)
{
    if (id >= _MiddlegroundParticleCount)
        return;
    
    ParticleOutput output = _Middleground0[id];
    UpdateOutput(output);
    
    _Middleground0[id] = output;
}

[numthreads(THREADS_PER_GROUP, 1, 1)]
void CSMiddleground1_Update(uint id : SV_DispatchThreadID)
{
    if (id >= _MiddlegroundParticleCount)
        return;
    
    ParticleOutput output = _Middleground1[id];
    UpdateOutput(output);
    _Middleground1[id] = output;
}

[numthreads(THREADS_PER_GROUP, 1, 1)]
void CSMiddleground2_Update(uint id : SV_DispatchThreadID)
{
    if (id >= _MiddlegroundParticleCount)
        return;
    
    ParticleOutput output = _Middleground2[id];
    UpdateOutput(output);
    _Middleground2[id] = output;
}

[numthreads(THREADS_PER_GROUP, 1, 1)]
void CSMiddleground3_Update(uint id : SV_DispatchThreadID)
{
    if (id >= _MiddlegroundParticleCount)
        return;
    
    ParticleOutput output = _Middleground3[id];
    UpdateOutput(output);
    _Middleground3[id] = output;
}

[numthreads(THREADS_PER_GROUP, 1, 1)]
void CSBackground0_Update(uint id : SV_DispatchThreadID)
{
    if (id >= _BackgroundParticleCount)
        return;
    
    ParticleOutput output = _Background0[id];
    UpdateOutput(output);
    _Background0[id] = output;
}

[numthreads(THREADS_PER_GROUP, 1, 1)]
void CSBackground1_Update(uint id : SV_DispatchThreadID)
{
    if (id >= _BackgroundParticleCount)
        return;
    
    ParticleOutput output = _Background1[id];
    UpdateOutput(output);
    _Background1[id] = output;
}

[numthreads(THREADS_PER_GROUP, 1, 1)]
void CSBackground2_Update(uint id : SV_DispatchThreadID)
{
    if (id >= _BackgroundParticleCount)
        return;
    
    ParticleOutput output = _Background2[id];
    UpdateOutput(output);
    _Background2[id] = output;
}